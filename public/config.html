<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Celsocam – Panel de Configuración</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        :root {
            --bg: #0f1115;
            --card: #161922;
            --muted: #a4adbb;
            --text: #e8edf5;
            --brand: #4f46e5;
            --brand-2: #374151;
            --ok: #22c55e;
            --bad: #ef4444;
            --input: #0b0e13;
            --border: #2a3140;
        }

        * {
            box-sizing: border-box
        }

        body {
            font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif;
            margin: 20px;
            color: var(--text);
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            margin: 0 0 14px
        }

        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 16px;
            margin-bottom: 18px;
        }

        .row {
            display: grid;
            grid-template-columns: 180px 1fr;
            gap: 8px 16px;
            align-items: center
        }

        .grid2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px
        }

        label {
            opacity: .85
        }

        select,
        input[type="number"] {
            width: 100%;
            max-width: 260px;
            padding: 10px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--input);
            color: var(--text)
        }

        input[type="checkbox"] {
            transform: scale(1.15)
        }

        .status {
            font-size: 14px;
            opacity: .9
        }

        .ok {
            color: var(--ok)
        }

        .bad {
            color: var(--bad)
        }

        .btns {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 12px
        }

        button {
            padding: 10px 14px;
            border: 0;
            border-radius: 10px;
            background: var(--brand);
            color: #fff;
            cursor: pointer
        }

        button.alt {
            background: var(--brand-2)
        }

        button:disabled {
            opacity: .55;
            cursor: not-allowed
        }

        .inline {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap
        }

        input[type="range"] {
            width: 260px
        }

        .pill {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 999px;
            background: var(--border);
            color: var(--muted)
        }

        #resHint {
            font-size: 12px;
            color: var(--muted)
        }

        @media (max-width:720px) {
            .row {
                grid-template-columns: 1fr
            }

            .grid2 {
                grid-template-columns: 1fr
            }
        }
    </style>
</head>

<body>
    <h1>Panel de Configuración</h1>

    <div class="card">
        <div class="row status">
            <label>Android:</label>
            <div id="stAndroid">—</div>
            <label>Navegador:</label>
            <div id="stBrowser">—</div>
        </div>
    </div>

    <div class="card">
        <h3 style="margin-top:0;">Parámetros</h3>

        <div class="row">
            <div>
                <label style="margin-right: 10px;" >Micrófono activo</label>
                <input type="checkbox" id="micEnabled" />
            </div>
        </div>

        <div class="row">
            <label>Cámara</label>
            <select id="camera">
                <option value="back">Trasera</option>
                <option value="front">Frontal</option>
            </select>
        </div>

        <div class="row">
            <label>Relación de aspecto</label>
            <select id="aspect">
                <option value="AUTO_MAX">Auto (máxima)</option>
                <option value="R16_9">16:9</option>
                <option value="R4_3">4:3</option>
                <option value="R1_1">1:1</option>
            </select>
        </div>

        <div class="row" style="margin-top:8px;">
            <label>Calidad (Resolución + FPS)</label>
            <div>
                <select id="quality"></select>
                <div id="resHint" style="margin-top:6px;"></div>
            </div>
        </div>

        <div class="row" style="margin-top:8px;">
            <label>Bitrate (kbps)</label>
            <div class="inline">
                <input type="range" id="bitrateRange" min="300" max="20000" step="100" />
                <input type="number" id="bitrateKbps" min="300" max="20000" step="50" style="max-width:120px" />
                <span class="pill" title="Rango recomendado según red">300–20000</span>
            </div>
        </div>

        <div class="btns">
            <button id="btnSave">Aplicar cambios</button>
            <button id="btnRefresh" class="alt">Refrescar</button>
        </div>
    </div>

    <script>
        const $ = id => document.getElementById(id);

        // ---- Estado de edición / refresh seguro ----
        let formDirty = false;
        let isSaving = false;
        let refreshTimer = null;

        const markDirty = () => { formDirty = true; };
        const clearDirty = () => { formDirty = false; };

        // ---- Utilidades aspecto ----
        const isClose = (a, b, t = 0.02) => Math.abs(a - b) < t;
        const ratio = (w, h) => w / h;
        function aspectFromWH(w, h) {
            const r = ratio(w, h);
            if (isClose(r, 16 / 9)) return "R16_9";
            if (isClose(r, 4 / 3)) return "R4_3";
            if (isClose(r, 1)) return "R1_1";
            return "AUTO_MAX";
        }
        function aspectMatch(w, h, aspect) {
            if (aspect === "AUTO_MAX") return true;
            const r = ratio(w, h);
            if (aspect === "R16_9") return isClose(r, 16 / 9);
            if (aspect === "R4_3") return isClose(r, 4 / 3);
            if (aspect === "R1_1") return isClose(r, 1);
            return true;
        }

        // ---- Fallback de calidades (si no hay /api/caps) ----
        const FALLBACK = {
            R16_9: [[3840, 2160, [30, 60]], [2560, 1440, [30, 60]], [1920, 1080, [24, 30, 60]], [1600, 900, [30]], [1280, 720, [24, 30, 60]], [960, 540, [30]], [854, 480, [30]], [640, 360, [30]]],
            R4_3: [[4000, 3000, [30]], [2560, 1920, [30]], [1920, 1440, [30, 60]], [1600, 1200, [30]], [1440, 1080, [30, 60]], [1280, 960, [30]], [1024, 768, [30]], [800, 600, [30]], [640, 480, [30, 60]]],
            R1_1: [[2992, 2992, [30]], [1088, 1088, [30, 60]], [1024, 1024, [30]], [960, 960, [30]], [720, 720, [30, 60]], [640, 640, [30]], [480, 480, [30]]]
        };

        // ---- Capabilities cache (si /api/caps está disponible) ----
        let CAPS = null; // { camera:"back|front", formats:[{w,h,fps:[..]}, ...] }

        async function tryLoadCaps() {
            try {
                const r = await fetch("/api/caps", { cache: "no-store" });
                if (!r.ok) return;
                CAPS = await r.json();
            } catch (_) {/* ignore */ }
        }

        // Devuelve lista de objetos {w,h,fps} ya filtrados por aspecto y cámara
        function qualityListFor(aspect, camera) {
            let list = [];

            if (CAPS && CAPS.formats && Array.isArray(CAPS.formats)) {
                // Si /api/caps existe: usarlo y filtrar por aspecto
                list = CAPS.formats
                    .filter(f => aspectMatch(f.w, f.h, aspect))
                    .flatMap(f => (f.fps || [30]).map(fr => ({ w: f.w, h: f.h, fps: fr })));
            } else {
                // Fallback
                const buckets = aspect === "AUTO_MAX"
                    ? [...FALLBACK.R16_9, ...FALLBACK.R4_3, ...FALLBACK.R1_1]
                    : (FALLBACK[aspect] || []);
                list = buckets.flatMap(([w, h, fpsArr]) => fpsArr.map(fr => ({ w, h, fps: fr })));
            }

            // Ordenar por resolución (área) desc, luego fps desc
            return list.sort((a, b) => {
                const A = a.w * a.h, B = b.w * b.h;
                if (A !== B) return B - A;
                return b.fps - a.fps;
            });
        }

        function fillQualitySelect(aspect, camera, curW, curH, curFps) {
            const sel = $("quality");
            sel.innerHTML = "";
            const list = qualityListFor(aspect, camera);

            let matchIdx = -1;
            list.forEach((q, i) => {
                const op = document.createElement("option");
                op.value = `${q.w}x${q.h}@${q.fps}`;
                op.textContent = `${q.w}×${q.h} @ ${q.fps} fps`;
                sel.appendChild(op);
                if (q.w === curW && q.h === curH && q.fps === curFps) matchIdx = i;
            });

            if (matchIdx === -1 && curW && curH && curFps) {
                const custom = document.createElement("option");
                custom.value = `${curW}x${curH}@${curFps}`;
                custom.textContent = `Personalizada (${curW}×${curH} @ ${curFps} fps)`;
                sel.insertBefore(custom, sel.firstChild);
                matchIdx = 0;
                $("resHint").textContent = "Calidad no estándar; se respetará si el dispositivo la soporta.";
            } else {
                $("resHint").textContent = "";
            }

            sel.selectedIndex = Math.max(0, matchIdx);
        }

        function parseQuality() {
            // value = "WxH@FPS"
            const [wh, fpsStr] = $("quality").value.split("@");
            const [w, h] = wh.split("x").map(n => parseInt(n, 10));
            return { w, h, fps: parseInt(fpsStr, 10) };
        }

        function syncBitrateUI(v) {
            const val = Math.min(20000, Math.max(300, parseInt(v || 0, 10)));
            $("bitrateRange").value = val;
            $("bitrateKbps").value = val;
        }

        async function loadConfig(updateForm = true) {
            if (isSaving) return;

            const res = await fetch("/api/config", { cache: "no-store" });
            const cfg = await res.json();

            // Estados de conexión: siempre refrescar
            $("stAndroid").innerHTML = cfg.androidConnected ? '<span class="ok">conectado</span>' : '<span class="bad">desconectado</span>';
            $("stBrowser").innerHTML = cfg.browserConnected ? '<span class="ok">conectado</span>' : '<span class="bad">desconectado</span>';

            if (!updateForm) return;

            $("micEnabled").checked = !!cfg.micEnabled;
            $("camera").value = cfg.camera === "front" ? "front" : "back";

            const aspect = cfg.aspect || aspectFromWH(cfg.width, cfg.height);
            $("aspect").value = aspect;
            fillQualitySelect(aspect, $("camera").value, cfg.width ?? 1280, cfg.height ?? 720, cfg.fps ?? 30);

            syncBitrateUI(cfg.bitrateKbps ?? 6000);
        }

        async function saveConfig() {
            isSaving = true;
            try {
                const { w, h, fps } = parseQuality();
                const payload = {
                    micEnabled: $("micEnabled").checked,
                    camera: $("camera").value,
                    aspect: $("aspect").value,
                    width: w, height: h, fps,
                    bitrateKbps: parseInt($("bitrateKbps").value, 10)
                };
                const res = await fetch("/api/config", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload)
                });
                const out = await res.json();
                if (out.ok) {
                    clearDirty();
                    await loadConfig(true);
                    alert("Cambios enviados. El teléfono aplicará la configuración.");
                } else {
                    alert("No se pudo aplicar la configuración.");
                }
            } finally { isSaving = false; }
        }

        // ---- Listeners (marcan dirty y mantienen UI) ----
        $("micEnabled").addEventListener("change", markDirty);
        $("camera").addEventListener("change", () => {
            markDirty();
            const { w, h, fps } = parseQuality();
            fillQualitySelect($("aspect").value, $("camera").value, w, h, fps);
        });
        $("aspect").addEventListener("change", () => {
            markDirty();
            const { w, h, fps } = parseQuality();
            fillQualitySelect($("aspect").value, $("camera").value, w, h, fps);
        });
        $("quality").addEventListener("change", markDirty);
        $("bitrateRange").addEventListener("input", e => { syncBitrateUI(e.target.value); markDirty(); });
        $("bitrateKbps").addEventListener("input", e => { syncBitrateUI(e.target.value); markDirty(); });

        $("btnSave").addEventListener("click", saveConfig);
        $("btnRefresh").addEventListener("click", () => loadConfig(!formDirty));

        // ---- Init ----
        (async () => {
            await tryLoadCaps();      // opcional; si no existe, usa fallback
            await loadConfig(true);   // carga inicial
            if (refreshTimer) clearInterval(refreshTimer);
            refreshTimer = setInterval(() => loadConfig(!formDirty), 3000);
        })();
    </script>
</body>

</html>